package Leetcode_BackTrack;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

/*
 * 单词搜索2
 *
	给定一个二维网格?board?和一个字典中的单词列表 words，找出所有同时在二维网格和字典中出现的单词。

	单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母在一个单词中不允许被重复使用。

	示例:

	输入: 
	words = ["oath","pea","eat","rain"] and board =
	[
	['o','a','a','n'],
	['e','t','a','e'],
	['i','h','k','r'],
	['i','f','l','v']
	]

	输出:?["eat","oath"]
	说明:
	你可以假设所有输入都由小写字母 a-z?组成。

	提示:

	你需要优化回溯算法以通过更大数据量的测试。你能否早点停止回溯？
	如果当前单词不存在于所有单词的前缀中，则可以立即停止回溯。什么样的数据结构可以有效地执行这样的操作？散列表是否可行？为什么？ 前缀树如何？如果你想学习如何实现一个基本的前缀树，请先查看这个问题： 实现Trie（前缀树）。
 */
public class leetcode_212 {
	static List<String> res = new ArrayList<>();
	static boolean[][] used;
	static int pathLength;
	public static List<String> findWords(char[][] board, String[] words) {
		for(String word: words){
			used = new boolean[board.length][board[0].length];
			pathLength = 0;
			for(int i=0; i<board.length; i++){
				for(int j=0; j<board[0].length; j++){
					if(findWordsSub(board, i, j, word, pathLength)){
						res.add(word);
					}
				}
			}
		}
		return res;
	}
	public static boolean findWordsSub(char[][] board, int row, int col, String word, int pathLength){
		boolean flag = false;
		if(row>=0 && row<board.length && col>=0 && col<board[0].length && !used[row][col] && board[row][col]==word.charAt(pathLength)){
			pathLength++;
			if(pathLength == word.length()){
				return true;
			}
			used[row][col] = true;
			flag = findWordsSub(board, row+1, col, word, pathLength) ||
					findWordsSub(board, row-1, col, word, pathLength) ||
					findWordsSub(board, row, col+1, word, pathLength) ||
					findWordsSub(board, row, col-1, word, pathLength);
			if(!flag){
				pathLength--;
				used[row][col] = false;
			}
		}
		return flag;
	}
	public static void main(String[] args) {
		char[][] board = {{'o', 'a', 'a', 'n'}, {'e', 't', 'a', 'e'}, {'i', 'h', 'k', 'r'}, {'i', 'f', 'l', 'v'}};
		String[] words = {"oath", "pea", "eat", "rain"};
		System.out.println("The board: ");
		for(int i=0; i<board.length; i++){
			for(char c:board[i]){
				System.out.print(c+" ");
			}
			System.out.println();
		}
		System.out.println("The words: ");
		for(String word: words){
			System.out.print(word+" ");
		}
		System.out.println("\nThe words is in the board: "+findWords(board, words));
	}

}


















